#!/usr/bin/env python2
# -*- coding: utf-8 -*-
##
# exchange2ical
# author: notizblock <nblock@archlinux.us>
# license: AGPLv3
# TODO:
# -check validity of each option before serving it (config)
# -more testing

import urllib2
import urllib
import sys
import Queue
import threading
import datetime
from BeautifulSoup import BeautifulSoup, Tag
import re
import codecs
from ConfigParser import SafeConfigParser
from icalendar import Calendar, Event
import socket
import os
import fcntl

class Config():
    '''read configuration from file and provide it via getattr()'''
    def __init__(self):
        self.configpath = ['/'.join((os.environ['HOME'],'.exchange2ical')), '/etc']
        self.basefile = u'exchange2icalrc'
        self.configfile = None
        self.section = u'exchange2ical'
        self.parser = SafeConfigParser()
        for path in self.configpath:
            tmp = '/'.join((path,self.basefile))
            if os.path.isfile(tmp):
                self.configfile = tmp
                break

        if not self.configfile:
            print 'No config file found. aborting!'
            sys.exit(1)

        with codecs.open(self.configfile, 'r', encoding='utf-8') as f:
            self.parser.readfp(f)

    def __getattr__(self, name):
        if self.parser.has_option(self.section, name):
            return self.parser.get(self.section, name, raw=True)
        else:
            return None

class ExchangeHelpers():
    '''a little helper class for Exchange'''
    def authenticate(self):
        '''authenticate with owa 
        
        True if ok, False otherwise'''
        c = Config()
        data = urllib.urlencode({
            u'username': c.username , 
            u'password': c.password,
            u'destination' : c.pf_url,
            u'flags' : u'0'})
        try:
            res = urllib2.urlopen(c.auth_url, data)
        except IOError, e:
            if hasattr(e, 'reason'):
                print 'an error occured during authentication (reason: %s). Exiting now.' % e.reason
                sys.exit(1)
            elif hasattr(e, 'code'):
                print 'The server couldn\'t fulfill the authentication request (error code: %s). Exiting now.' % e.code
                sys.exit(1)

class ThreadExchange(threading.Thread):
    '''Threaded Exchange fetcher'''
    def __init__(self, url_queue, html_queue):
        threading.Thread.__init__(self)
        self.url_queue = url_queue
        self.html_queue = html_queue

    def run(self):
        while True:
            #...?Cmd=contents&View=Daily&m=11&d=11&y=2010
            (d,m,y) = self.url_queue.get()
            url = (u'%s?Cmd=contents&View=Daily&m=%s&d=%s&y=%s' % (Config().pf_url, m, d, y))

            try:
                chunk = unicode(urllib2.urlopen(url).read(), 'utf-8')
                start = chunk.find('<TABLE class="calDayVwTbl')
                end = chunk.find('</TABLE>',start)
            
                #put table in html_queue
                self.html_queue.put((chunk[start:end+len('</TABLE>')], (d,m,y)))
            except IOError, e:
                if hasattr(e, 'reason'):
                    print 'an error occured while fetching calendar resource (reason: %s).' % e.reason
                    print 'entries from %s.%s.%s will not be included in the calendar file.' % (d,m,y)
                elif hasattr(e, 'code'):
                    print 'The server couldn\'t fulfill the request (error code: %s).' % e.code

            self.url_queue.task_done()

class ThreadDatamine(threading.Thread):
    '''Threaded dataminer'''
    def __init__(self, html_queue, cal_queue):
        threading.Thread.__init__(self)
        self.html_queue = html_queue
        self.cal_queue = cal_queue

    def run(self):
        while True:
            #grabs host from queue
            (chunk, (d,m,y)) = self.html_queue.get()

            #parse the chunk
            soup = BeautifulSoup(chunk)
            tds = soup.findAll('td', {'title' : True})
            for elem in tds:    #each event
                event = Event()
                gmt1 = GMT1()

                #extract time
                tfoo = elem['title']
                mo=re.match('^\d{2}:\d{2}-\d{2}:\d{2}',tfoo)
                if mo:  #regular time
                    dstart = datetime.datetime(y, m, d, int(tfoo[:2]), int(tfoo[3:5]), tzinfo=gmt1)
                    dend = datetime.datetime(y, m, d, int(tfoo[6:8]), int(tfoo[9:11]), tzinfo=gmt1)
                else:   #whole day event (just a date object)
                    dstart = dend = datetime.date(y, m, d)
                
                event.add('dtstart', dstart)
                event.add('dtend', dend)
                event.add('dtstamp', datetime.datetime.now(tz=gmt1))

                #extract title
                if len(elem.next.next.contents) == 2:
                    title = elem.next.next.contents[1]
                    #if title is a text: use element 0
                    if isinstance(title, Tag):
                        title = elem.next.next.contents[0]
                else:
                    title = elem.next.next.contents[0]
                #replace some crap
                title = re.sub('&amp;', '&', title, re.IGNORECASE)
                title = re.sub('&nbsp;', ' ', title, re.IGNORECASE)
                event.add('summary', title)
                event.add('description', title)
                
                #extract location (if possible)
                mo = re.match('.*\((.*)\)$', title)
                if mo:
                    event.add('location', mo.group(1).strip())
            
                #event object of icalender
                self.cal_queue.put(event)
            self.html_queue.task_done()

class GMT1(datetime.tzinfo):
    '''Timezone Class for GMT+1'''
    def utcoffset(self,dt):
        return datetime.timedelta(hours=1,minutes=00)
    def tzname(self,dt):
        return "GMT +1"
    def dst(self,dt):
        return datetime.timedelta(0) 

def iter_except(func, exception, first=None):
    '''Call a function repeatedly until an exception is raised.'''
    try:
        if first is not None:
            yield first()            # For database APIs needing an initial cast to db.first()
        while 1:
            yield func()
    except exception:
        pass

def main():
    sdt = datetime.datetime.now() 
    print 'start exchange2ical (%s)' % sdt

    url_queue = Queue.Queue()
    html_queue = Queue.Queue()
    cal_queue = Queue.Queue()
    c = Config()
    socket.setdefaulttimeout(int(c.timeout)) #apply global timeout
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor())
    urllib2.install_opener(opener)

    eh = ExchangeHelpers().authenticate()

    #spawn some fetchers
    for i in range(int(c.url_threads)):
        t = ThreadExchange(url_queue, html_queue)
        t.setDaemon(True)
        t.start()

    #populate url_queue with data
    for x in range(int(c.days)):
        da = datetime.datetime.today()+datetime.timedelta(x)
        url_queue.put((da.day, da.month, da.year))

    #spawn some datamining threads
    for i in range(int(c.html_threads)):
        dt = ThreadDatamine(html_queue, cal_queue)
        dt.setDaemon(True)
        dt.start()
    
    #wait until data processing has been finished
    url_queue.join()
    html_queue.join()

    #write everything to a file
    cal = Calendar()
    cal.add('prodid', '-//exchange2ical//mxm.dk//')
    cal.add('version', '2.0')
    for elem in iter_except(cal_queue.get_nowait, Queue.Empty):
        cal.add_component(elem)

    try:
        with codecs.open(c.ics_file,'w', 'utf-8') as f:
            f.write(unicode(cal.as_string(), 'utf-8'))
    except IOError:
        print 'cannot write to file "%s" (permission denied).' % c.ics_file
    
    enddt = datetime.datetime.now() 
    print 'finished exchange2ical (%s). Elapsed time: %s' % (enddt, enddt-sdt)

if __name__ == '__main__':
    #here is our entry point
    lock_file = Config().lock_file
    fp = open(lock_file, 'w')
    try:
        fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
        main()      #do work
        fp.close()  #close and clean up
        os.unlink(lock_file)
    except IOError:
        print 'another instance is running. exiting now.'
        sys.exit(1)

# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 smartindent autoindent 
